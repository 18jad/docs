---
title: 'Create custom Prisma Client queries'
metaTitle: 'Prisma Client extensions (Preview)'
metaDescription: 'Extend the functionality of Prisma Client'
tocDepth: 3
---

<TopBlock>

<Admonition type="info">

This page is in draft for Prisma version 4.6.0. We plan to publish this page for version 4.7.0.

</Admonition>

From version 4.7.0, you can use `query` [Prisma Client extensions](/concepts/components/prisma-client/client-extensions) to create custom Prisma Client queries. Extended queries return type-safe data and, like all Prisma Client extensions, [run in isolated instances](/concepts/components/prisma-client/client-extensions#multiple-extensions).

</TopBlock>

## Add the <inlinecode>clientExtensions</inlinecode> feature flag to <inlinecode>schema.prisma</inlinecode>

Before you create Prisma Client extensions, you must enable the `clientExtensions` feature flag in the generator block of your `schema.prisma` file, as follows:

```prisma
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["clientExtensions"]
}
```

## Create custom queries

To create Prisma Client extensions, use the [`$extends`](/concepts/components/prisma-client/client-extensions#about-prisma-client-extensions) client-level method. To extend queries, use the `query` extension type.

The following example queries the database to find users older than 18 years:

```ts
const xprisma = prisma.$extends({
  query: {
    user: {
      async findMany({ model, action, args, data }) {
        args.where.age = { gt: 18 }
        const myData = await data
        return data
      },
    },
  },
})

await xprisma.user.findMany() // returns users whose age is greater than 18
```

### Nested operations

You can handle nested operations with the `$nestedOperations` option. You can recursively traverse the arguments of a given operation, as follows:
** I need more detail here - ask Frederik **

```ts
const xprisma = prisma.$extends({
  query: {
    user: {
      $nestedOperations: {
        where({ model, operation, args, data, path }) {
          // path here could be `user.findFirst`

          args.where.age = { gt: 18 }
        },
      },
    },
  },
})
```

The `$allModels` is available for `query` extensions.
**_ TBD will this be $allQueries ? _**

---

```ts
const xprisma = prisma.$extends({
  query: {
    user: {
      findFirst({ model, operation, args, data }) {
        args.where.age.gte = 18
        return data
      },
      findMany({ model, operation, args, data }) {
        args.where.age.gte = 18
        return data
      },
    },
  },
})

xprisma.user.findMany() // only returns users aged 18 or above
```

`query` is an object that contains functions that map to the names of the Prisma Client operations. `findUnique`, `findFirst`, `findMany`, `count`, `create`... are the kind of names that are expected. For this example, calling `xprisma.user.findFirst` would trigger `query.findFirst` on execution. Each callback will receive a type-safe `{ model, operation, args, data }` object describing a query:

- `model` — a property name of the modeproduct design documentl whose query is being extended.
  In this specific example, the `model` would be a string of type `"User"`.
- `operation` — a property name of the operation being extended and executed.
  In this specific example, the `o`peration would be a string of type `"findFirst"`/`"findMany"`.
- `args` — a property that carries the specific query input information to be extended.
  This is a type-safe object that is meant to be mutated before the query happens. All the properties within `args` can be mutated except for the ones that would break type-safety. In essence, you cannot modify `include` or `select` because that would change the expected output type in such a way that it breaks type safety.
- `data` — a property that is a promise of the result of the query that is being executed.
  This promise can be `await`ed and then mutated as its value is also type-safe, so TypeScript will catch any unsafe mutations on that object. Doing `await data` is equivalent to calling `next(...)` in a middleware. You are free to mutate `args` before `then` is triggered, which leads to a more natural way of writing such extensions. `args` is fully type-safe, meaning that some properties are `readonly`, (like `includes` or `select`) which you would immediately notice if you are using TypeScript.

Additionally, because this is a declarative interface for hooking and extending queries, it will also be possible to handle nested queries. `query` will accept wildcard operations for handling any levels of nesting. The following hooks map to operation properties from Prisma Client operations to execute:

- `connect` / `connectOrCreate`
- `create` / `createMany`
- `delete` / `deleteMany`
- `select` / `include`
- `disconnect`
- `set`
- `update` / `updateMany`
- `upsert`
- `where`

These are not real operations, but are parts of a query that can be deeply nested or even applied via another model (eg. via a relation query).

```ts
const xprisma = prisma.$extends({
  query: {
    user: {
      create({ model, operation, args, data, path }) {
        // handle all prisma.user.create

        return data
      },
      $nestedOperations: {
        create({ model, operation, args, path }) {
          // handle nested create for user
        },
      },
    },
  },
})
```

- `$nestedOperations` — an optional property for handling deeply nested operations.
- `path` — a property that describes the level of nesting of such an operation.

Note: Recursive wildcards cannot return values but can just modify the query itself.

Finally, query will also offer and support many wildcard properties as the other extension layers:

```ts
const xprisma = prisma.$extends({
  query: {
    $allModels: {
      $allOperations({ model, operation, args, data }) {
        // handle all operations

        return data
      },
      $nestedOperations: {
        create({ model, operation, args, data, path }) {
          // handle nested operations

          return data
        },
      },
    },
  },
})
```

- `$allModels` — an optional property for handling all models within a single extension.
- `$allOperations` — an optional property for handling all operations for a given model.
- `$nestedOperations` — an optional property for handling specific nested operations.
