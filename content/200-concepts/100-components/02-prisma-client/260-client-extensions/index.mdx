---
title: 'Prisma Client extensions'
metaTitle: 'Prisma Client extensions (Preview)'
metaDescription: 'Extend the functionality of Prisma Client'
preview: true
tocDepth: 3
---

<TopBlock>

<Admonition type="info">

This page is in draft for Prisma version 4.6.0. We plan to publish this page for version 4.7.0.

</Admonition>

You can use Prisma Client extensions to add functionality to Prisma Client in the following ways:

- Add custom methods to your models
- Add custom results objects to Prisma Client
- Create custom Prisma Client queries
- Add client-level methods to Prisma Client

To create Prisma Client extensions, use the `$extends` client-level method. `$extends` returns a forked state of Prisma Client. This means that you can create [multiple extensions](#multiple-extensions), each in is own isolated instance of Prisma Client.

You can also [share your Prisma Client extensions](#share-extensions) with other Prisma users, and [import Prisma Client extensions developed by other users](#install-a-packaged-extension) into your Prisma project.

</TopBlock>

## Docs notes (this section to be removed)

Still to do:

- Any workarounds that overlap with examples in this section - link from there to here - e.g. middlewares - ** check for candidates, and add to issue ticket **
- Explain how type utilities can be used in $extends for full type-safety - need info on this

## Prerequisites

To use Prisma Client extensions, you must enable the `clientExtensions` feature flag in the generator block of your `schema.prisma` file, as follows:

```prisma
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["clientExtensions"]
}
```

**Are there any dependencies you need to install?**

## How to extend Prisma Client

To learn how to extend Prisma Client, and to see examples, visit the appropriate page for the type of extension you want to make:

- [Add custom methods to your models](/concepts/components/prisma-client/client-extensions/client-extensions-model)
- [Add custom results objects to Prisma Client](/concepts/components/prisma-client/client-extensions/client-extensions-results)
- [Create custom Prisma Client queries](/concepts/components/prisma-client/client-extensions/client-extensions-query)
- [Add client-level methods to Prisma Client](/concepts/components/prisma-client/client-extensions/client-extensions-client)

## Multiple extensions

Each extension that you create operates independently and cannot conflict with other extensions. Therefore, you can use extensions to create multiple variations of Prisma Client for different purposes, and use them simultaneously. For example, you might have a `result` extension for one purpose and a `model` extension for another.

When you use `$extends`, you get a forked state of Prisma Client. This adds a new layer of extensions on top of the previous client, each one based on the state of the original client. This process does not change the state of the original client. Each extensions is independent, because it operates in an isolated instance of Prisma Client.

This "forking" process is completely virtual. It does not fork the engine process of Prisma Client. It re-uses the same engine and the same connection pool. The only added overhead is the extension execution.

In the following example, each call to `$extends` creates a completely separate client:

```ts
const xprisma = prisma
.$extends({ ... }) // returns an extended client from the original client
.$extends({ ... }) // returns an extended client from the extended client
.$extends({ ... }) // returns an extended client from the extended client
```

## Share Prisma Client extensions

You can share Prisma Client extensions with other users, either as packages or as code snippets.

To create an extension that works for other users, you can use the `$all` prefix, for example `$allModels`. This lets you build an extension that applies generally, and not just to your specific application.

For example, a generic extension might take the following form:

```ts
const xprisma = new prisma.$extends({
  model: {
    $allModels: {
      getClass<T extends object>(this: T): new () => T {
        return class {
          /** Generic Implementation */
        } as any
      },
    },
  },
})

class UserService extends xprisma.user.getClass() {
  method() {
    const user = this.findFirst({}) // fully typesafe
  }
}
```

### Package an extension

To package an extension, use `Prisma.createExtension`. This is a mirror of `prisma.$extends`, but lets you declare an extension. For example:

```ts
import { Prisma } from '@prisma/client'

export default Prisma.createExtension(({ client }) => ({
  model: {
    $allModels: {
      getClass<T extends object>(this: T): new () => T {
        return class {
          /** Generic Implementation */
        } as any
      },
    },
  },
}))
```

`Prisma.createExtension` vs `prisma.$extends(...)`
In the examples, `prisma` is the client _instance_. The client instance can immediately hook an extension in. But since an extension author will not be able to access that, they need to package an extension before hand, so that it can later be consumed by `prisma.$extends`.

This is useful for the following reasons:

- This method will provide the exact same inference capabilities as `prisma.$extends`. This means that an extension author will benefit from types at development time, but it also means that types will be packaged correctly. It is a necessary step for making TypeScript inference work from one end to another.
- This can also be a way for us to inject metadata about the extension (one example that comes to mind is adding the client version is was packaged for).

Naming convention: `prisma-extension-<name>`

Other example:

```ts

import { Prisma } from '@prisma/client'

export default Prisma.createExtension({
  model: {
    $allModels: {
      // new method
      findOrCreate(...) { }
    }
  }
})
```

Usage:

```ts
import findOrCreate from 'prisma-extension-find-or-create'

const xprisma = prisma.$extends(findOrCreate)
const user = await xprisma.user.findOrCreate({ ... })
```

### Install a packaged extension

** How do you discover the pacakaged extensions - how do you know what's available? **

In your project, you can install any Prisma Client extension that another user user has published to `npm`. To do so, add the following line to your application code:

```ts
npm install prisma-extension-model-to-class
```

Import the extension and load it into your client instance as follows:

```ts
import ModelToClass from 'prisma-extension-model-to-class'

const xprisma = prisma.$extends(ModelToClass)

xprisma.user.getClass()
```

### Out of scope

** not sure what this means, but it sounds like a consideration we need to flag up - maybe on each extensions page **

You can't use computed fields in conjunction with MongoDB composite fields.

### Callbacks

Do we want to cover this here?
https://www.notion.so/prismaio/Product-Design-for-Client-Extensions-ac2f334ac0a7483e9bb65d1656023f5f#8554166fcbf744c4979afbd9ff8a7aac
