---
title: 'Add custom results objects to Prisma Client'
navTitle: 'Results'
metaTitle: 'Prisma Client extensions: results (Preview)'
metaDescription: 'Extend the functionality of Prisma Client'
preview: true
tocDepth: 3
---

<TopBlock>

<Admonition type="info">

This page is in draft for Prisma version 4.6.0. We plan to publish this page for version 4.7.0.

</Admonition>

You can use [Prisma client extensions](/concepts/components/prisma-client/client-extensions) to add custom results objects to Prisma Client.

</TopBlock>

## Add custom results objects to Prisma Client

<Admonition type="info">

Before you add a custom model, you must satisfy the [prerequsites for client extensions](/concepts/components/prisma-client/client-extensions#prerequisites).

</Admonition>

result is designed to “augment” results. This can be used to add fields to query results, computed at runtime and in a type safe way.

Example use cases for `$result `:

- [Virtual fields](#virtual-fields)
- [Field augmentation](#field-augmentation)
- [Excluded fields](#excluded-fields)
- [Custom methods on operation results](#custom-methods-on-operation-results)

Example:

```ts
const xprisma = prisma.$extends({
  result: {
    user: {
      needs: {
        fullName: { firstName: true, lastName: true },
      },
      fields: {
        fullName(user) {
          return `${user.firstName} ${user.lastName}`
        },
      },
    },
  },
})
```

this extends the User model with a new, virtual field fullName. We declared the field's dependencies and the computation logic.

```ts
const user = await xprisma.user.findFirst()
console.log(user.fullName) // "John Doe"
Result extensions don't over-fetch. Fields are only computed if its dependencies are present:

const user = await xprisma.user.findFirst({ select: { email: true }))
console.log(user.fullName) // undefined
```

For performance reasons, results are only computed when accessed at runtime.

Result extensions can be used to add methods to result objects:

```ts
const xprisma = prisma.$extends({
  result: {
    user: {
      needs: {
        getAccountBalance: {
          account: true,
        },
      },
      fields: {
        getAccountBalance: (user) => (n: number) => {
          return user.account.balance + n
        },
      },
    },
  },
})
const result = await xprisma.user.findFirst()
console.log(result?.getAccountBalance(-500)) // 7245
```

### Add fields and methods to query results

** Is it fields, too, or just methods? **

- `result` — an optional field to add fields/methods to query results.

`result` extensions can be used to augment already existing fields or to come up with brand new virtual fields from existing ones in the database.

WHAT DO WE MEAN HERE - AT RUN TIME? ARE THEY STORED TEMPORARILY AS THE APP RUNS?

What makes `result` extensions powerful is that, unlike the model fields, their fields are aware of the surrounding context and can return any kind of types, including ones that are ambient and application-specific. Fields as defined by the schema, by design, cannot re-use TypeScript types. TypeScript cannot flow into the schema, but the schema flows into TypeScript. It’s probably stating the obvious to highlight why a computed field is better being defined on the Client side rather than in the schema, that is a benefit in terms of types and values that can be returned. E.g. if you field is augmented to be a React component (<Photo/>), the schema can't represent that in a way that the types work when generated.

```ts
const xprisma = prisma.$extends({
  result: {
    user: {
      needs: {
        fullName: {
          firstName: true,
          lastName: true,
        },
      },
      fields: {
        fullName(user) {
          return `${user.firstName} ${user.lastName}`
        },
      },
    },
  },
})

const result = await xprisma.user.findFirst()

console.log(result?.fullName) // "John Doe"
```

- `needs` — a required object which describes the dependencies of a result field.

  ```ts
  needs: {
  	fullName: {
  		firstName: true,
  		lastName: true
  	}
  }
  ```

  This is the declaration of such a dependency where, in this example, `fullName` depends on `firstName` and `lastName`. This is useful because we can have a declarative way of defining field dependencies, which TypeScript can understand and give useful intellisense.
  The other reason behind this is that because you can include or exclude fields and relations via `select` and `include` in your queries, we need to know ahead of time what the needs of a new field will be. In other words, virtual fields will not be computed if a declared dependency is missing. For the above example:

  ```ts
  const result = await xprisma.user.findFirst({ select: { lastName: true } })

  console.log(result?.fullName) // undefined
  ```

  This means that result extensions will never over-fetch, but only compute if the field is present in the results. And of course, this is going to work both in the runtime and on type level.

  ```ts
  const result = await xprisma.user.findFirst({ select: { fullName: true } })

  console.log(result?.fullName) // "John Doe"
  ```

  ```ts
  const result = await xprisma.user.findFirst()

  console.log(result?.fullName) // "John Doe"
  ```

  {' '}

The current design only supports virtual fields that are based on scalar
fields. In future developments, we may want to allow `needs` to
select/include relations. In that case, because computed fields would depend
on a relation, the field would be treated as being a relation too. It must
be selected or included, but will not be included by default.

`fields` — a required object which describes the computation of a virtual field.

```ts
fields: {
	fullName(user) {
		return `${user.firstName} ${user.lastName}`
	}
}
```

This is a mirror of the `needs` object, what is declared in `needs` must exist in `fields`. It contains methods that describe the how the virtual field will be computed once it is accessed (for performance reasons, virtual fields are computed on access instead of on retrieval).
In this snippet, the input `user` is automatically typed according to the `needs`. This means that in this scope, we are sure `firstName` and `lastName` will be of type `string` because they were specified in the `needs`. If they weren’t, their type would be `string | undefined`.

- `return` — the value of the field that has been computed, which can be anything.

  ```ts
  return `${user.firstName} ${user.lastName}` // type string
  ```

  In this example, this is the value and the type that will be available on the result. Regardless of the kind of result, the declared fields are always present given their `needs` have been satisfied. This means they will appear on the results of simple queries but also on more complex queries with relations that might also have virtual fields of their own.

## Example use cases

** Link to these from the layer sections above - e.g. link to virtual fields from result section **

### Virtual fields

**uses result**

Virtual fields allow one to augment the query results with fields that are computed at runtime. They allow to infer new fields that are not present in the database into query results. Such fields can be computed together from existing fields and/or other external data. Typically, virtual fields are used anytime a query returns direct model data (on client level).

Technically speaking, result extensions are virtual fields. So this use case is completely covered.

```ts
const xprisma = prisma.$extends({
  result: {
    user: {
      needs: {
        fullName: {
          firstName: true,
          lastName: true,
        },
      },
      fields: {
        fullName(user) {
          return `${user.firstName} ${user.lastName}`
        },
      },
    },
  },
})

const result = await xprisma.user.findFirst()

console.log(result?.fullName) // "John Doe"
```

### Field augmentation

**uses result**

Field augmentation is a way to take a field from the database and inflate it into a higher-order field. Concretely, if you have a model `User` that has a `Photo` whose contents are stored as a `String` (eg. in `Base64`), you could augment your result type so that instead of a `String`, you’d have a React `<Photo />` component ready. This concept is closely tied to virtual fields.

Technically speaking, `result` extensions support overriding a field, which in turn can be translated to field augmentation. So this use case is completely covered.

```ts
const xprisma = prisma.$extends({
  result: {
    user: {
      needs: {
        photo: {
          content: true,
        },
      },
      fields: {
        photo(user) {
          return <Photo data={user.photo.content} />
        },
      },
    },
  },
})

const result = await xprisma.user.findFirst()

console.log(result?.photo) // now <Photo/> instead of { content: string }
```

### Excluded fields

**uses result**

Excluded fields as described in this issue would allow to exclude fields per query. Currently, there is a way to select the fields you need, but there is not way to exclude the fields you don’t need. The workaround requires you to include all the fields, except the ones you don’t want. This issue is the home for more requests that are related. For instance, there is a clear ask for always excluding certain fields via the schema.

This use case is partially covered, it will be a solution for some users but not for all. Some users want the ability to be able to exclude per query, others to exclude via the schema. Extensions can provide an in-between solution. It does not really satisfy the ones that want to exclude it per query nor does it satisfy the ones that want to exclude it via the schema. However, it does provide a solution for achieving this:

```ts
const xprisma = prisma.$extends({
  result: {
    user: {
      fields: {
        password() {
          return undefined
        },
      },
    },
  },
})

const result = await xprisma.user.findFirst()

console.log(result?.password) // undefined
```

### Custom methods on operation results

**Uses result**

Get results with methods attached to them.

This issue is fully covered by `result`. Just like a virtual field, one can return a custom method.

```ts
const xprisma = prisma.$extends({
  result: {
    user: {
      needs: {
        getAccountBalance: {
          account: true,
        },
      },
      fields: {
        getAccountBalance: (user) => (n: number) => {
          return user.account.balance + n
        },
      },
    },
  },
})

const result = await xprisma.user.findFirst()

console.log(result?.getAccountBalance(-500)) // 7245
```
