---
title: 'Prisma Client extensions'
metaTitle: 'Prisma Client extensions (Preview)'
metaDescription: 'Extend the functionality of Prisma Client'
preview: true
tocDepth: 3
---

<TopBlock>

You can use Prisma Client extensions to add functionality to Prisma Client in the following ways:

- Add custom results objects to Prisma Client
- Add custom methods on your models
- Customize Prisma Client **(can we be a bit more specific here?)**

**Explain that you can share your extensions with other Prisma users - link to sharing and use shared extensions sections.**

</TopBlock>

## Docs notes

- We will release this page as a draft doc for 4.6.

Heading structure:

- intro
- considerations and prerequisites
- model
- result
- client
- example use cases
- share client extensions
- use a shared extension

other docs to update:

- Client reference - Client methods section - brief mention, and link to this page - DONE
- Any workarounds that overlap with examples on this page - link here
- Add feature flag to preview features page (for version 4.7)

**For the docs to be complete, we will need how type utilities can be used in $extends for full type-safety.**

## Considerations and prerequisites

**Mention $extends**

`$extends` returns a forked state of Prisma client. This means that you can create multiple extensions, each in is own isolated instance of Prisma Client. **why would you want this?**

To use Prisma Client extensions, you must [enable the `clientExtensions` feature flag](#enable-the-clientextensions-feature-flag-in-your-prisma-schema-file).

**Are there any dependencies you need to install?**

### Enable the <inlinecode>clientExtensions</inlinecode> feature flag in your Prisma schema file

In the generator block of your schema.prisma file, enable the `clientExtensions` feature flag:

```prisma
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["clientExtensions"]
}
```

## Extend a model

You can use Prisma Client extensions to add custom methods and fields to a specific model in your schema, or to all models in your schema. **(is it fields, or just methods?)** For example, you might add a new mthod to handle business logic.

Example use cases for `$model`:

- [Custom respositories](#custom-repositories)
- [Soft deletes](#soft-deletes)
- [Business logic](#business-logic)

**!!!got here!!!**
along existing Prisma Client operations (eg. findMany, create, etc…) to already existing models. These can be new operations, encapsulated business logic, repetitive operations, or even model-specific utilities. model blindly takes an object that contains methods and makes its known properties available on a model.

When you extend a specific model, you can add methods or fields (**is that the right term?**) to a model.

In the following example, we add `signUp` to the user model.

```ts
const xprisma = prisma.$extends({
  model: {
    user: {
      async signUp(email: string) {
        await prisma.user.create(...)
      },
    },
  }
})
```

You can call `signUp` as follows:

`const user = await xprisma.user.signUp('john@prisma.io')`

The model User was augmented with a signUp method to wrap user creation and account logic. signUp can now be called from anywhere via your model and via the extension:

To extend the client, call the [Prisma Client method](/reference/api-reference/prisma-client-reference#client-methods) `$extends`.

To extend a specific model:

```ts
const xprisma = prisma.$extends({
  name?: '<name>',
  model?: {
    user: { ... }
  },
});
```

`name` is an optional field. You can use it to give a name to the extension. This name will appear in error logs, tracing, ?metrics?).

To extend all models:

```ts
const xprisma = prisma.$extends({
  name?: '<name>',
  model?: {
   $allModels: { ... }
   },
 })
```

Other example:

```ts
const xprisma = new prisma.$extends({
  model: {
    $allModels: {
      getClass<T extends object>(this: T): new () => T {
        return class {
          /** Generic Implementation */
        } as any
      },
    },
  },
})
```

The `getClass` method is now accessible from all models. For example:

```ts
class UserService extends xprisma.user.getClass() {
  method() {
    const user = this.findFirst({}) // fully typesafe
  }
}
```

### <inlinecode>$result</inlinecode> extensions

result is designed to “augment” results. This can be used to add fields to query results, computed at runtime and in a type safe way.

Example use cases for `$result `:

- [Virtual fields](#virtual-fields)
- [Field augmentation](#field-augmentation)
- [Excluded fields](#excluded-fields)
- [Custom methods on operation results](#custom-methods-on-operation-results)

Example:

```ts
const xprisma = prisma.$extends({
  result: {
    user: {
      needs: {
        fullName: { firstName: true, lastName: true },
      },
      fields: {
        fullName(user) {
          return `${user.firstName} ${user.lastName}`
        },
      },
    },
  },
})
```

this extends the User model with a new, virtual field fullName. We declared the field's dependencies and the computation logic.

```ts
const user = await xprisma.user.findFirst()
console.log(user.fullName) // "John Doe"
Result extensions don't over-fetch. Fields are only computed if its dependencies are present:

const user = await xprisma.user.findFirst({ select: { email: true }))
console.log(user.fullName) // undefined
```

For performance reasons, results are only computed when accessed at runtime.

Result extensions can be used to add methods to result objects:

```ts
const xprisma = prisma.$extends({
  result: {
    user: {
      needs: {
        getAccountBalance: {
          account: true,
        },
      },
      fields: {
        getAccountBalance: (user) => (n: number) => {
          return user.account.balance + n
        },
      },
    },
  },
})
const result = await xprisma.user.findFirst()
console.log(result?.getAccountBalance(-500)) // 7245
```

### Extend Prisma Client

You can use `$client` to allow top-level customization of Prisma client. It works in the same way as `model` extensions, except that they are not bound to any specific model and you must always call them with a `$` prefix to prevent conflicts with model names.

Example use cases for `$client`:

- [Customized interactive transactions](#customized-interactive-transactions)

** IS this the same as the example use case below? **
** Maybe bring the use cases into their associated sections anyway **

An example use case is to start an interactive transaction without callbacks, as follows:

```ts
const xprisma = prisma.$extends({
  client: {
    method(args:) { ... }, // the code goes inside the curly braces
  }
})

xprisma.$method
```

Now we can start an interactive transaction omitting the traditional callback:

```ts

const tx = await xprisma.$begin()

await tx.user.create(...)
await tx.user.update(...)

await tx.$commit()

```

### Add fields and methods to query results

** Is it fields, too, or just methods? **

- `result` — an optional field to add fields/methods to query results.

`result` extensions can be used to augment already existing fields or to come up with brand new virtual fields from existing ones in the database.

WHAT DO WE MEAN HERE - AT RUN TIME? ARE THEY STORED TEMPORARILY AS THE APP RUNS?

What makes `result` extensions powerful is that, unlike the model fields, their fields are aware of the surrounding context and can return any kind of types, including ones that are ambient and application-specific. Fields as defined by the schema, by design, cannot re-use TypeScript types. TypeScript cannot flow into the schema, but the schema flows into TypeScript. It’s probably stating the obvious to highlight why a computed field is better being defined on the Client side rather than in the schema, that is a benefit in terms of types and values that can be returned. E.g. if you field is augmented to be a React component (<Photo/>), the schema can't represent that in a way that the types work when generated.

```ts
const xprisma = prisma.$extends({
  result: {
    user: {
      needs: {
        fullName: {
          firstName: true,
          lastName: true,
        },
      },
      fields: {
        fullName(user) {
          return `${user.firstName} ${user.lastName}`
        },
      },
    },
  },
})

const result = await xprisma.user.findFirst()

console.log(result?.fullName) // "John Doe"
```

- `needs` — a required object which describes the dependencies of a result field.

  ```ts
  needs: {
  	fullName: {
  		firstName: true,
  		lastName: true
  	}
  }
  ```

  This is the declaration of such a dependency where, in this example, `fullName` depends on `firstName` and `lastName`. This is useful because we can have a declarative way of defining field dependencies, which TypeScript can understand and give useful intellisense.
  The other reason behind this is that because you can include or exclude fields and relations via `select` and `include` in your queries, we need to know ahead of time what the needs of a new field will be. In other words, virtual fields will not be computed if a declared dependency is missing. For the above example:

  ```ts
  const result = await xprisma.user.findFirst({ select: { lastName: true } })

  console.log(result?.fullName) // undefined
  ```

  This means that result extensions will never over-fetch, but only compute if the field is present in the results. And of course, this is going to work both in the runtime and on type level.

  ```ts
  const result = await xprisma.user.findFirst({ select: { fullName: true } })

  console.log(result?.fullName) // "John Doe"
  ```

  ```ts
  const result = await xprisma.user.findFirst()

  console.log(result?.fullName) // "John Doe"
  ```

  {' '}

The current design only supports virtual fields that are based on scalar
fields. In future developments, we may want to allow `needs` to
select/include relations. In that case, because computed fields would depend
on a relation, the field would be treated as being a relation too. It must
be selected or included, but will not be included by default.

`fields` — a required object which describes the computation of a virtual field.

```ts
fields: {
	fullName(user) {
		return `${user.firstName} ${user.lastName}`
	}
}
```

This is a mirror of the `needs` object, what is declared in `needs` must exist in `fields`. It contains methods that describe the how the virtual field will be computed once it is accessed (for performance reasons, virtual fields are computed on access instead of on retrieval).
In this snippet, the input `user` is automatically typed according to the `needs`. This means that in this scope, we are sure `firstName` and `lastName` will be of type `string` because they were specified in the `needs`. If they weren’t, their type would be `string | undefined`.

- `return` — the value of the field that has been computed, which can be anything.

  ```ts
  return `${user.firstName} ${user.lastName}` // type string
  ```

  In this example, this is the value and the type that will be available on the result. Regardless of the kind of result, the declared fields are always present given their `needs` have been satisfied. This means they will appear on the results of simple queries but also on more complex queries with relations that might also have virtual fields of their own.

## Example use cases

** Link to these from the layer sections above - e.g. link to virtual fields from result section **

### Virtual fields

**uses result**

Virtual fields allow one to augment the query results with fields that are computed at runtime. They allow to infer new fields that are not present in the database into query results. Such fields can be computed together from existing fields and/or other external data. Typically, virtual fields are used anytime a query returns direct model data (on client level).

Technically speaking, result extensions are virtual fields. So this use case is completely covered.

```ts
const xprisma = prisma.$extends({
  result: {
    user: {
      needs: {
        fullName: {
          firstName: true,
          lastName: true,
        },
      },
      fields: {
        fullName(user) {
          return `${user.firstName} ${user.lastName}`
        },
      },
    },
  },
})

const result = await xprisma.user.findFirst()

console.log(result?.fullName) // "John Doe"
```

### Field augmentation

**uses result**

Field augmentation is a way to take a field from the database and inflate it into a higher-order field. Concretely, if you have a model `User` that has a `Photo` whose contents are stored as a `String` (eg. in `Base64`), you could augment your result type so that instead of a `String`, you’d have a React `<Photo />` component ready. This concept is closely tied to virtual fields.

Technically speaking, `result` extensions support overriding a field, which in turn can be translated to field augmentation. So this use case is completely covered.

```ts
const xprisma = prisma.$extends({
  result: {
    user: {
      needs: {
        photo: {
          content: true,
        },
      },
      fields: {
        photo(user) {
          return <Photo data={user.photo.content} />
        },
      },
    },
  },
})

const result = await xprisma.user.findFirst()

console.log(result?.photo) // now <Photo/> instead of { content: string }
```

### Excluded fields

**uses result**

Excluded fields as described in this issue would allow to exclude fields per query. Currently, there is a way to select the fields you need, but there is not way to exclude the fields you don’t need. The workaround requires you to include all the fields, except the ones you don’t want. This issue is the home for more requests that are related. For instance, there is a clear ask for always excluding certain fields via the schema.

This use case is partially covered, it will be a solution for some users but not for all. Some users want the ability to be able to exclude per query, others to exclude via the schema. Extensions can provide an in-between solution. It does not really satisfy the ones that want to exclude it per query nor does it satisfy the ones that want to exclude it via the schema. However, it does provide a solution for achieving this:

```ts
const xprisma = prisma.$extends({
  result: {
    user: {
      fields: {
        password() {
          return undefined
        },
      },
    },
  },
})

const result = await xprisma.user.findFirst()

console.log(result?.password) // undefined
```

### Custom repositories

**Uses model**

Use Entities to represent your database tables. Let you add methods that can encapsulate business logic, while adding curom fields.

This issue is fully covered by writing a `getClass` model method for a generic extension.

```ts
const xprisma = new prisma.$extends({
  model: {
    $allModels: {
      getClass<T extends object>(this: T): new () => T {
        return class {
          /** Generic Implementation */
        } as any
      },
    },
  },
})

class UserService extends xprisma.user.getClass() {
  method() {
    const user = this.findFirst({}) // fully typesafe
  }
}
```

### Custom methods on operation results

**Uses result**

Get results with methods attached to them.

This issue is fully covered by `result`. Just like a virtual field, one can return a custom method.

```ts
const xprisma = prisma.$extends({
  result: {
    user: {
      needs: {
        getAccountBalance: {
          account: true,
        },
      },
      fields: {
        getAccountBalance: (user) => (n: number) => {
          return user.account.balance + n
        },
      },
    },
  },
})

const result = await xprisma.user.findFirst()

console.log(result?.getAccountBalance(-500)) // 7245
```

### Customized interactive transactions

**Uses client**

One use-case for using interactive transactions is testing. Testing with a database can be difficult for a few reasons like needing to clean the data after each test, or having to create an isolated database for each test. With interactive transactions, database mutations can be performed and rolled back at the end the test, almost out of the box. However, this is not possible because iTX is designed (for good reasons) to be used via a callback.

```ts
const xprisma = prisma.$extends({
	client: {
		begin() { ... }, // the code I shared in that issue
	}
})

const tx = await xprisma.$begin()

await tx.user.create(...)
await tx.user.update(...)

await tx.$commit()
```

### Soft deletes

**Uses model**

Note - this has not been confirmed

```ts
const xprisma = prisma.$extends({
  model: {
    $allModels: {
      async softDelete<T>(this: T, cascade = true) {
        modelName = this['name']
        // TODO - missing implementation here
        // 1. use the dmmf to look at the relations
        // 2. traverse th dmmf and collect relations
        // 3 .filter the relations that can be soft deleted
        // 4. create raw sql queries to set the `deleted = true`
        // 5. Send them as a batch via a sequential transaction
      },
    },
  },
  query: {
    $nestedOperations: {
      where({ model, action, args, path }) {
        // TODO - first check if the model has a `deleted` field
        args.where.deleted = false
      },
    },
  },
})
```

### Business logic

**uses model**

There is a need to organize business logic and creating higher level abstractions for data-fetching logic.

```ts
const xprisma = prisma.$extends(({ client }) => {
return {
model: {
user: {
async signUp(email: any) {
return client.user.create(...)
}
}
}
}
})

const result = await xprisma.user.create({ email: 'abc@prisma.io' })
```

Or:

```ts
const xprisma = prisma.$extends({
model: {
user: {
async signUp(email: any) {
return prisma.user.create(...)
}
}
}
})


const result = await xprisma.user.signUp({ email: 'abc@prisma.io' })
```

## Share extensions

You can share Client Extensions as packages or code snippets.

You'd generally use the $all prefix - e.g. $allModels to apply to all models, not just a specic one

So a genertic extension might be:

```ts
const xprisma = new prisma.$extends({
  model: {
    $allModels: {
      getClass<T extends object>(this: T): new () => T {
        return class {
          /** Generic Implementation */
        } as any
      },
    },
  },
})

class UserService extends xprisma.user.getClass() {
  method() {
    const user = this.findFirst({}) // fully typesafe
  }
}
```

### Package an extentiosn

```ts
import { Prisma } from '@prisma/client'

export default Prisma.createExtension(({ client }) => ({
  model: {
    $allModels: {
      getClass<T extends object>(this: T): new () => T {
        return class {
          /** Generic Implementation */
        } as any
      },
    },
  },
}))
```

`Prisma.createExtension` — a mirror of `prisma.$extends` but for declaring an extension.
The important bit here is `Prisma.createExtension` vs `prisma.$extends(...)`. In the examples, `prisma` is the client _instance_. The client instance can immediately hook an extension in. But since an extension author will not be able to access that, they need to package an extension before hand, so that it can later be consumed by `prisma.$extends`.
This is useful for two reasons. The first one is that this method will provide the exact same inference capabilities as `prisma.$extends`. This means that an extension author will benefit from types at development time, but it also means that types will be packaged correctly. It is a necessary step for making TypeScript inference work from one end to another. The second reason is that this can also be a way for us to inject metadata about the extension (one example that comes to mind is adding the client version is was packaged for).

Naming convention:
`prisma-extension-<name>`

Other example:

```ts

import { Prisma } from '@prisma/client'

export default Prisma.createExtension({
  model: {
    $allModels: {
      // new method
      findOrCreate(...) { }
    }
  }
})
```

Usage:

import findOrCreate from 'prisma-extension-find-or-create'

const xprisma = prisma.$extends(findOrCreate)
const user = await xprisma.user.findOrCreate({ ... })

#### Install a pacakaged extension

** How do you discover the pacakaged extensions - how do you know what's available? **

Once an extension has been published to `npm`, a user would install the extension in their project:

```ts
npm install prisma-extension-model-to-class
```

In your app, import the extension and load it into your client instance:

```ts
import ModelToClass from 'prisma-extension-model-to-class'

const xprisma = prisma.$extends(ModelToClass)

xprisma.user.getClass()
```

### Use extensions to organize code

You can use Prisma.createExtension to organize code. If we're covering that, then I need more details.

### Out of scope

You can't use computed fields in conjunction with MongoDB composite fields.

### Callbacks

Do we want to cover this here?
https://www.notion.so/prismaio/Product-Design-for-Client-Extensions-ac2f334ac0a7483e9bb65d1656023f5f#8554166fcbf744c4979afbd9ff8a7aac
