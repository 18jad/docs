---
title: 'Prisma Client extensions'
metaTitle: 'Prisma Client extensions (Preview)'
metaDescription: 'Extend the functionality of Prisma Client'
preview: true
tocDepth: 3
---

<TopBlock>

You can use Prisma Client extensions to add functionality to Prisma Client.

You can currently extend Prisma Client in the following ways:

- `result`: add custom results objects to Prisma Client
- `model`: add custom methods on your models
- `client`: customize Prisma Client

**Note: other docs to update:**

- Client reference - Client methods section - brief mention, and link to this page
- Any workarounds that overlap with examples on this page - link here
- Add feature flag to preview features page (for version 4.7)
- We will release this page as a draft

For the docs to be complete, we will need how type utilities can be used in $extends for full type-safety.

Checklist to go through:

- Proposal: https://github.com/prisma/prisma/issues/15074#issuecomment-1282419200
- https://www.notion.so/prismaio/Prisma-Client-Extensions-7dfe94ab8cfb4145ba4c11e96297af04#ae40517ff0344696bf136e4d31398e27
- Product design: https://www.notion.so/prismaio/Product-Design-for-Client-Extensions-ac2f334ac0a7483e9bb65d1656023f5f - Done

<Admonition type="info">

Prisma Client extensions currently let you extend models. In future Prisma releases, we will add extensibility layers to let you extend results, queries, and Prisma Client itself. **FIND A BETTER WAY TO SUMMARIZE THE LAYERS**

</Admonition>

</TopBlock>

## Considerations and prerequisites

Are there any dependencies you need to install?

Mention:
`$extends` returns a forked state of Prisma client. This allows the creation of isolated instances of Prisma client extended by different extensions.

### Enable the feature flag in your Prisma schema file

In the generator block of your schema.prisma file, enable the `clientExtensions` feature flag:

```prisma
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["clientExtensions"]
}
```

## Extend a model

You can use Prisma Client extensions to add custom methods and fields a specific model or to all models. (is it fields, or just methods?)

e.g. a new mthod to handle business logic:

In the following example, we add `signUp` to the user model.

```ts
const xprisma = prisma.$extends({
  model: {
    user: {
      async signUp(email: string) {
        await prisma.user.create(...)
      },
    },
  }
})
```

You can call `signUp` as follows:

`const user = await xprisma.user.signUp('john@prisma.io')`

along existing Prisma Client operations (eg. findMany, create, etc…) to already existing models. These can be new operations, encapsulated business logic, repetitive operations, or even model-specific utilities. model blindly takes an object that contains methods and makes its known properties available on a model.

When you extend a specific model, you can add methods or fields (**is that the right term?**) to a model.

To extend the client, call the [Prisma Client method](/reference/api-reference/prisma-client-reference#client-methods) `$extends`.

To extend a specific model:

```ts
const xprisma = prisma.$extends({
  name?: '<name>',
  model?: {
    user: { ... }
  },
});
```

`name` is an optional field. You can use it to give a name to the extension. This name will appear in error logs, tracing, ?metrics?).

To extend all models:

```ts
const xprisma = prisma.$extends({
  name?: '<name>',
  model?: {
   $allModels: { ... }
   },
 })
```

```ts
const xprisma = new prisma.$extends({
  model: {
    $allModels: {
      getClass<T extends object>(this: T): new () => T {
        return class {
          /** Generic Implementation */
        } as any
      },
    },
  },
})
```

The getClass method is now accessible from all model:

```ts
class UserService extends xprisma.user.getClass() {
  method() {
    const user = this.findFirst({}) // fully typesafe
  }
}
```

### $result extensions

also document this

### Extend Prisma Client

`$client` is designed to allow top-level customization of Prisma client. They work in the same way as `model` extensions, except that they are not bound to any specific model and you must always call them with a `$` prefix to prevent conflicts with model names.

An example use case is to start an interactive transaction without callbacks, as follows:

```ts
const xprisma = prisma.$extends({
  client: {
    method(args:) { ... }, // the code goes inside the curly braces
  }
})

xprisma.$method
```

Now we can start an interactive transaction omitting the traditional callback:

```ts
const tx = await xprisma.$begin()

await tx.user.create(...)
await tx.user.update(...)

await tx.$commit()
```

### Extend result

- `result` — an optional field to add fields/methods to query results.

`result` extensions can be used to augment already existing fields or to come up with brand new virtual fields from existing ones in the database.

WHAT DO WE MEAN HERE - AT RUN TIME? ARE THEY STORED TEMPORARILY AS THE APP RUNS?

What makes `result` extensions powerful is that, unlike the model fields, their fields are aware of the surrounding context and can return any kind of types, including ones that are ambient and application-specific. Fields as defined by the schema, by design, cannot re-use TypeScript types. TypeScript cannot flow into the schema, but the schema flows into TypeScript. It’s probably stating the obvious to highlight why a computed field is better being defined on the Client side rather than in the schema, that is a benefit in terms of types and values that can be returned. E.g. if you field is augmented to be a React component (<Photo/>), the schema can't represent that in a way that the types work when generated.

```ts
const xprisma = prisma.$extends({
  result: {
    user: {
      needs: {
        fullName: {
          firstName: true,
          lastName: true,
        },
      },
      fields: {
        fullName(user) {
          return `${user.firstName} ${user.lastName}`
        },
      },
    },
  },
})

const result = await xprisma.user.findFirst()

console.log(result?.fullName) // "John Doe"
```

- `needs` — a required object which describes the dependencies of a result field.

  ```ts
  needs: {
  	fullName: {
  		firstName: true,
  		lastName: true
  	}
  }
  ```

  This is the declaration of such a dependency where, in this example, `fullName` depends on `firstName` and `lastName`. This is useful because we can have a declarative way of defining field dependencies, which TypeScript can understand and give useful intellisense.
  The other reason behind this is that because you can include or exclude fields and relations via `select` and `include` in your queries, we need to know ahead of time what the needs of a new field will be. In other words, virtual fields will not be computed if a declared dependency is missing. For the above example:

  ```ts
  const result = await xprisma.user.findFirst({ select: { lastName: true } })

  console.log(result?.fullName) // undefined
  ```

  This means that result extensions will never over-fetch, but only compute if the field is present in the results. And of course, this is going to work both in the runtime and on type level.

  ```ts
  const result = await xprisma.user.findFirst({ select: { fullName: true } })

  console.log(result?.fullName) // "John Doe"
  ```

  ```ts
  const result = await xprisma.user.findFirst()

  console.log(result?.fullName) // "John Doe"
  ```

  {' '}

The current design only supports virtual fields that are based on scalar
fields. In future developments, we may want to allow `needs` to
select/include relations. In that case, because computed fields would depend
on a relation, the field would be treated as being a relation too. It must
be selected or included, but will not be included by default.

`fields` — a required object which describes the computation of a virtual field.

```ts
fields: {
	fullName(user) {
		return `${user.firstName} ${user.lastName}`
	}
}
```

This is a mirror of the `needs` object, what is declared in `needs` must exist in `fields`. It contains methods that describe the how the virtual field will be computed once it is accessed (for performance reasons, virtual fields are computed on access instead of on retrieval).
In this snippet, the input `user` is automatically typed according to the `needs`. This means that in this scope, we are sure `firstName` and `lastName` will be of type `string` because they were specified in the `needs`. If they weren’t, their type would be `string | undefined`.

- `return` — the value of the field that has been computed, which can be anything.

  ```ts
  return `${user.firstName} ${user.lastName}` // type string
  ```

  In this example, this is the value and the type that will be available on the result. Regardless of the kind of result, the declared fields are always present given their `needs` have been satisfied. This means they will appear on the results of simple queries but also on more complex queries with relations that might also have virtual fields of their own.

## Example use cases

### Virtual fields

**uses result**

Virtual fields allow one to augment the query results with fields that are computed at runtime. They allow to infer new fields that are not present in the database into query results. Such fields can be computed together from existing fields and/or other external data. Typically, virtual fields are used anytime a query returns direct model data (on client level).

Technically speaking, result extensions are virtual fields. So this use case is completely covered.

```ts
const xprisma = prisma.$extends({
  result: {
    user: {
      needs: {
        fullName: {
          firstName: true,
          lastName: true,
        },
      },
      fields: {
        fullName(user) {
          return `${user.firstName} ${user.lastName}`
        },
      },
    },
  },
})

const result = await xprisma.user.findFirst()

console.log(result?.fullName) // "John Doe"
```

### Field augmentation

**uses result**

Field augmentation is a way to take a field from the database and inflate it into a higher-order field. Concretely, if you have a model `User` that has a `Photo` whose contents are stored as a `String` (eg. in `Base64`), you could augment your result type so that instead of a `String`, you’d have a React `<Photo />` component ready. This concept is closely tied to virtual fields.

Technically speaking, `result` extensions support overriding a field, which in turn can be translated to field augmentation. So this use case is completely covered.

```ts
const xprisma = prisma.$extends({
  result: {
    user: {
      needs: {
        photo: {
          content: true,
        },
      },
      fields: {
        photo(user) {
          return <Photo data={user.photo.content} />
        },
      },
    },
  },
})

const result = await xprisma.user.findFirst()

console.log(result?.photo) // now <Photo/> instead of { content: string }
```

### Excluded fields

**uses result**

Excluded fields as described in this issue would allow to exclude fields per query. Currently, there is a way to select the fields you need, but there is not way to exclude the fields you don’t need. The workaround requires you to include all the fields, except the ones you don’t want. This issue is the home for more requests that are related. For instance, there is a clear ask for always excluding certain fields via the schema.

This use case is partially covered, it will be a solution for some users but not for all. Some users want the ability to be able to exclude per query, others to exclude via the schema. Extensions can provide an in-between solution. It does not really satisfy the ones that want to exclude it per query nor does it satisfy the ones that want to exclude it via the schema. However, it does provide a solution for achieving this:

```ts
const xprisma = prisma.$extends({
  result: {
    user: {
      fields: {
        password() {
          return undefined
        },
      },
    },
  },
})

const result = await xprisma.user.findFirst()

console.log(result?.password) // undefined
```

### Custom repositories

**Uses model**

Use Entities to represent your database tables. Let you add methods that can encapsulate business logic, while adding curom fields.

This issue is fully covered by writing a `getClass` model method for a generic extension.

```ts
const xprisma = new prisma.$extends({
  model: {
    $allModels: {
      getClass<T extends object>(this: T): new () => T {
        return class {
          /** Generic Implementation */
        } as any
      },
    },
  },
})

class UserService extends xprisma.user.getClass() {
  method() {
    const user = this.findFirst({}) // fully typesafe
  }
}
```

### Custom methods

**Uses result**

Get results with methods attached to them.

This issue is fully covered by `result`. Just like a virtual field, one can return a custom method.

```ts
const xprisma = prisma.$extends({
  result: {
    user: {
      needs: {
        getAccountBalance: {
          account: true,
        },
      },
      fields: {
        getAccountBalance: (user) => (n: number) => {
          return user.account.balance + n
        },
      },
    },
  },
})

const result = await xprisma.user.findFirst()

console.log(result?.getAccountBalance(-500)) // 7245
```

### Customized iTX

**Uses client**

One use-case for using interactive transactions is testing. Testing with a database can be difficult for a few reasons like needing to clean the data after each test, or having to create an isolated database for each test. With interactive transactions, database mutations can be performed and rolled back at the end the test, almost out of the box. However, this is not possible because iTX is designed (for good reasons) to be used via a callback.

```ts
const xprisma = prisma.$extends({
	client: {
		begin() { ... }, // the code I shared in that issue
	}
})

const tx = await xprisma.$begin()

await tx.user.create(...)
await tx.user.update(...)

await tx.$commit()
```

### Soft deletes

**Uses model**

Note - this has not been confirmed

```ts
const xprisma = prisma.$extends({
  model: {
    $allModels: {
      async softDelete<T>(this: T, cascade = true) {
        modelName = this['name']
        // TODO - missing implementation here
        // 1. use the dmmf to look at the relations
        // 2. traverse th dmmf and collect relations
        // 3 .filter the relations that can be soft deleted
        // 4. create raw sql queries to set the `deleted = true`
        // 5. Send them as a batch via a sequential transaction
      },
    },
  },
  query: {
    $nestedOperations: {
      where({ model, action, args, path }) {
        // TODO - first check if the model has a `deleted` field
        args.where.deleted = false
      },
    },
  },
})
```

### Business logic

**uses model**

There is a need to organize business logic and creating higher level abstractions for data fetching logic.

const xprisma = prisma.$extends(({ client }) => {
return {
model: {
user: {
async signUp(email: any) {
return client.user.create(...)
}
}
}
}
})

const result = await xprisma.user.create({ email: 'abc@prisma.io' })

Or:

const xprisma = prisma.$extends({
model: {
user: {
async signUp(email: any) {
return prisma.user.create(...)
}
}
}
})

const result = await xprisma.user.signUp({ email: 'abc@prisma.io' })

## Share extensions

You can share Client Extensions as packages or code snippets.

You'd generally use the $all prefix - e.g. $allModels to apply to all models, not just a specic one

So a genertic extension might be:

```ts
const xprisma = new prisma.$extends({
  model: {
    $allModels: {
      getClass<T extends object>(this: T): new () => T {
        return class {
          /** Generic Implementation */
        } as any
      },
    },
  },
})

class UserService extends xprisma.user.getClass() {
  method() {
    const user = this.findFirst({}) // fully typesafe
  }
}
```

### Package an extentiosn

```ts
import { Prisma } from '@prisma/client'

export default Prisma.createExtension(({ client }) => ({
  model: {
    $allModels: {
      getClass<T extends object>(this: T): new () => T {
        return class {
          /** Generic Implementation */
        } as any
      },
    },
  },
}))
```

`Prisma.createExtension` — a mirror of `prisma.$extends` but for declaring an extension.
The important bit here is `Prisma.createExtension` vs `prisma.$extends(...)`. In the examples, `prisma` is the client _instance_. The client instance can immediately hook an extension in. But since an extension author will not be able to access that, they need to package an extension before hand, so that it can later be consumed by `prisma.$extends`.
This is useful for two reasons. The first one is that this method will provide the exact same inference capabilities as `prisma.$extends`. This means that an extension author will benefit from types at development time, but it also means that types will be packaged correctly. It is a necessary step for making TypeScript inference work from one end to another. The second reason is that this can also be a way for us to inject metadata about the extension (one example that comes to mind is adding the client version is was packaged for).

Naming convention:
`prisma-extension-<name>`

Other example:

```ts

import { Prisma } from '@prisma/client'

export default Prisma.createExtension({
  model: {
    $allModels: {
      // new method
      findOrCreate(...) { }
    }
  }
})
```

Usage:

import findOrCreate from 'prisma-extension-find-or-create'

const xprisma = prisma.$extends(findOrCreate)
const user = await xprisma.user.findOrCreate({ ... })

#### Install a pacakaged extension

Once an extension has been published to `npm`, a user would install the extension in their project:

```
npm install prisma-extension-model-to-class
```

In your app, import the extension and load it into your client instance:

```ts
import ModelToClass from 'prisma-extension-model-to-class'

const xprisma = prisma.$extends(ModelToClass)

xprisma.user.getClass()
```

### Use extensions to organize code

You can use Prisma.createExtension to organize code. If we're covering that, then I need more details.

### Out of scope

You can't use computed fields in conjunction with MongoDB composite fields.

### Callbacks

Do we want to cover this here?
https://www.notion.so/prismaio/Product-Design-for-Client-Extensions-ac2f334ac0a7483e9bb65d1656023f5f#8554166fcbf744c4979afbd9ff8a7aac
